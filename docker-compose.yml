version: '3.8'

services:
  maxqr-api:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: maxqr-api
    restart: unless-stopped
    ports:
      - "${PORT:-8080}:8080"
    environment:
      # Server - optimized for high concurrency
      - PORT=8080
      - HOST=0.0.0.0
      - READ_TIMEOUT=5s
      - WRITE_TIMEOUT=10s
      - SHUTDOWN_TIMEOUT=30s

      # Security
      - API_KEY=${API_KEY:-f650396397eac879bcb510b35e53c6c3}
      - ALLOWED_ORIGINS=${ALLOWED_ORIGINS:-*}
      - ENABLE_CORS=true

      # Rate Limiting - high throughput
      - RATE_LIMIT_ENABLED=true
      - RATE_LIMIT_PER_SECOND=${RATE_LIMIT_PER_SECOND:-1000}
      - RATE_LIMIT_BURST=${RATE_LIMIT_BURST:-2000}

      # Cache - optimized for high hit rate
      - CACHE_ENABLED=true
      - CACHE_MAX_SIZE_MB=${CACHE_MAX_SIZE_MB:-256}
      - CACHE_DEFAULT_TTL=10m
      - CACHE_CLEANUP_INTERVAL=5m

      # QR Generation
      - QR_DEFAULT_SIZE=300
      - QR_MAX_SIZE=500

      # Logging - production mode
      - LOG_LEVEL=${LOG_LEVEL:-info}

      # Go runtime tuning
      - GOMAXPROCS=0
      - GOGC=100

    # Resource limits for high performance
    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 1G
        reservations:
          cpus: '1'
          memory: 256M

    # Kernel tuning via sysctls
    sysctls:
      - net.core.somaxconn=65535
      - net.ipv4.tcp_tw_reuse=1

    # ulimits for high concurrency
    ulimits:
      nofile:
        soft: 65535
        hard: 65535

    # Health check - using curl from host or skip for scratch image
    # Note: scratch image has no shell, use external health checks
    healthcheck:
      test: ["NONE"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 10s

    # Logging
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "5"

  # High-performance setup with multiple replicas
  maxqr-api-scaled:
    build:
      context: .
      dockerfile: Dockerfile
    restart: unless-stopped
    deploy:
      mode: replicated
      replicas: ${REPLICAS:-3}
      resources:
        limits:
          cpus: '2'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 128M
    environment:
      - PORT=8080
      - HOST=0.0.0.0
      - CACHE_ENABLED=true
      - CACHE_MAX_SIZE_MB=128
      - RATE_LIMIT_ENABLED=false
      - LOG_LEVEL=info
    profiles:
      - scaled

  # Nginx load balancer for scaled deployment
  nginx:
    image: nginx:alpine
    container_name: maxqr-nginx
    restart: unless-stopped
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - maxqr-api-scaled
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 128M
    profiles:
      - scaled

networks:
  default:
    name: maxqr-network
    driver: bridge
    driver_opts:
      com.docker.network.driver.mtu: 1500
